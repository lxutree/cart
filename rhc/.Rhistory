if (is.null(sigma.a)) { sigma.a <- sqrt(sigma.e^2 * rho/(1 - rho)) }
if (is.null(sigma.e)) { sigma.e <- sqrt(sigma.a^2 * (1 - rho)/rho) }
if (is.null(rho)) { rho <- (sigma.a^2/(sigma.e^2 + sigma.a^2)) }
}
if (family == "binomial"){
if (sum(c(is.null(rho), is.null(sigma.a))) !=1) {
stop("Exactly one of rho and sigma.a must be null")}
if(!is.null(sigma.e)){warning("sigma.e will be computed from the baseline risk and treatment effect instead of the input value")}
mu1 <- Tx.effect * (mu0/(1 - mu0))/(1 + Tx.effect * (mu0/(1 - mu0)))
sigma.e <- sqrt((mu0 * (1 - mu0) + mu1 * (1 - mu1))/2)
if (is.null(sigma.a)) { sigma.a <- sqrt(sigma.e^2 * rho/(1 - rho)) }
if (is.null(rho)) { rho <- (sigma.a^2/(sigma.e^2 + sigma.a^2)) }
}
if (family == "poisson"){
if (sum(c(is.null(rho), is.null(sigma.a))) !=1) {
stop("Only one of rho and sigma.a must be null")}
if(!is.null(sigma.e)){warning("sigma.e will be computed from the baseline rate and treatment effect instead of the input value")}
mu1 <- Tx.effect * mu0
sigma.e <- sqrt((mu0 + mu1)/2)
if (is.null(sigma.a)) {
sigma.a <- sqrt(sigma.e^2 * rho/(1 - rho))}
if (is.null(rho)) {
rho <- (sigma.a^2/(sigma.e^2 + sigma.a^2)) }
}
if (design == "pcrt"){
# allocation-specific power:
power.rep <- foreach(iterators::icount(rep), .packages = c("arrangements", "Matrix") , .export = c("rand", "multi", "alloc1", "freq", "DesignMatrix", "all_allocs", "all_allocs_strat"), .combine = rbind ) %dorng% {
# generate design matrices for all unique allocations
Design_out <- DesignMatrix(I = I, J = J, P = P, K = K, S = S, strat = strat, factor.time = factor.time, user.allocs = user.allocs, design = design)
XMat = Design_out$XMat
size = Design_out$size
if (family == "gaussian") {
# generate covariance matrix for cross-sectional design
Ve <- diag(1, nrow = sum(size))
Vclus <- lapply(1:sum(I), FUN = function(clus) {
matrix(1, nrow = size[clus], ncol = size[clus])
})
Vclus <- bdiag(Vclus)
VV <- as.matrix(sigma.e^2 * Ve + sigma.a^2 * Vclus)
# power calculation
power <- sapply(XMat, FUN = function(XMat_i) {
VarTx <- solve(t(XMat_i) %*% solve(VV) %*% XMat_i)[1, 1]
pnorm(Tx.effect/sqrt(VarTx) - qnorm(1 - sig.level/2), lower.tail = T) +
pnorm(-Tx.effect/sqrt(VarTx) - qnorm(1 - sig.level/2),
lower.tail = T)
})
}
if (family == "binomial") {
# only AML has been implemented for binary outcome
b0 <- log(mu0/(1 - mu0))
b1 <- log(Tx.effect)
power <- sapply(XMat, FUN = function(XMat_i) {
vec_pi <- as.vector(1 + exp(-(XMat_i %*% c(b1, b0))))^(-1)
clus.id <- split(1:sum(size), rep(1:sum(I), size))
FIM <- lapply(1:sum(I), FUN = function(ii) {
VClus <- matrix(1, nrow = size[ii], ncol = size[ii])
WWi_inv <- solve(diag(vec_pi[clus.id[[ii]]] * (1 - vec_pi[clus.id[[ii]]])))
VV <- WWi_inv + sigma.a^2 * VClus
t(XMat_i[clus.id[[ii]], ]) %*% solve(VV) %*% XMat_i[clus.id[[ii]],
]
})
FIM <- Reduce("+", FIM)
VarTx <- solve(FIM)[1, 1]
pnorm(b1/sqrt(VarTx) - qnorm(1 - sig.level/2), lower.tail = T) +
pnorm(-b1/sqrt(VarTx) - qnorm(1 - sig.level/2), lower.tail = T)
})
}
if (family == "poisson") {
# only AML has been implemented for count outcome
b0 <- log(mu0)
b1 <- log(Tx.effect)
power <- sapply(XMat, FUN = function(XMat_i) {
vec_lambda <- as.vector(exp(XMat_i %*% c(b1, b0)))
clus.id <- split(1:sum(size), rep(1:sum(I), size))
FIM <- lapply(1:sum(I), FUN = function(ii) {
VClus <- matrix(1, nrow = size[ii], ncol = size[ii])
WWi_inv <- solve(diag(vec_lambda[clus.id[[ii]]]))
VV <- WWi_inv + sigma.a^2 * VClus
t(XMat_i[clus.id[[ii]], ]) %*% solve(VV) %*% XMat_i[clus.id[[ii]],
]
})
FIM <- Reduce("+", FIM)
VarTx <- solve(FIM)[1, 1]
pnorm(b1/sqrt(VarTx) - qnorm(1 - sig.level/2), lower.tail = T) +
pnorm(-b1/sqrt(VarTx) - qnorm(1 - sig.level/2), lower.tail = T)
})
}
power
}
CV <- sd(K)/mean(K)
if (family == "gaussian") {
# Manatunga et al. (2001) Sample size estimation in cluster randomized
# studies with varying cluster size:
power.CV <- pnorm(sqrt(sum(I)/2 * mean(K) * Tx.effect^2/2/sigma.e^2/(1 + ((CV^2 + 1) * mean(K) - 1) * rho)) - qnorm(p = (1 - sig.level/2)))
}
if (family == "binomial") {
# Kang et al. (2003) Sample size calculation for dichotomous outcomes
# in cluster randomization trials with varying cluster size:
power.CV <- pnorm(sqrt(sum(I)/2 * mean(K) * (mu1 - mu0)^2/(1 + ((CV^2 + 1) * mean(K) - 1) * rho)/(mu0 * (1 - mu0) + mu1 * (1 - mu1))) - qnorm(p = (1 - sig.level/2)))
}
if (family == "poisson") {
# Wang et al. (2018) Sample size calculation for count outcomes in
# cluster randomization trials with varying cluster sizes:
power.CV <- pnorm(sqrt(sum(I)/2 * (mu1 - mu0)^2 * mean(K)/(mu1 + mu0)/(1 +  ((CV^2 + 1) * mean(K) - 1) * rho)) - qnorm(p = (1 - sig.level/2)))
}
}
if (design == "sw") {
if (is.list(P)){np <- length(P[[1]])} else {np <- length(P)}
K_per <- K / (np+1)
ncpp <- round(sum(I)/np) # number of cluster per period
CV <- sd(K_per*(np+1))/mean(K_per*(np+1))
tol <- sum(K_per*(np+1)) ### total size
m <- mean(K_per)
DE_C <- 1+(m*(1+CV^2)-1)*rho
r <- (m*(1+CV^2)*rho)/DE_C
DE_R <- 3*np*(1-r)*(1+np*r)/(((np^2)-1)*(2+np*r))
## Power.CV is based on Hemming et al 2020 "A tutorial on sample size calculation for multiple-period cluster randomized parallel,
## cross-over and stepped-wedge trials using the Shiny CRT Calculator"
if (family == "gaussian"){
ses <- abs(Tx.effect)/sigma.e
power.CV <- pnorm(sqrt(np*m*ncpp*(ses^2)/(4*DE_C*DE_R))-qnorm(1-sig.level/2))
}
if (length(Time.effect) != 1){avg_time <- Time.effect} else {avg_time <- (c(0:length(P)))*(Time.effect)}
if (family == "binomial"){
mu0_bin <- mean(1/(1+exp(-(log(mu0/(1-mu0)) + avg_time))))
mu1_bin <- mean(1/(1+exp(-(log(mu0/(1-mu0)) + log(Tx.effect) + avg_time))))
sigma.e_bin <- sqrt((mu0_bin * (1 - mu0_bin) + mu1_bin * (1 - mu1_bin))/2)
ses <- abs(mu1_bin-mu0_bin)/sigma.e_bin
power.CV <- pnorm(sqrt(np*m*ncpp*(ses^2)/(4*DE_C*DE_R))-qnorm(1-sig.level/2))
}
if (family == "poisson"){
mu0_count <- mean(exp(log(mu0) + avg_time))
mu1_count <- mean(exp(log(mu0) + log(Tx.effect) + avg_time))
sigma.e_count <- sqrt((mu0_count + mu1_count)/2)
ses <- abs(mu1_count-mu0_count)/sigma.e_count
power.CV <- pnorm(sqrt(np*m*ncpp*(ses^2)/(4*DE_C*DE_R))-qnorm(1-sig.level/2))
}
power.rep <- foreach(iterators::icount(rep), .packages = c("arrangements", "Matrix") , .export = c("rand", "multi", "alloc1", "freq", "DesignMatrix", "all_allocs", "all_allocs_strat"), .combine = rbind ) %dorng% {
# generate design matrices for all unique allocations
Design_out <- DesignMatrix(I = I, J = J, P = P, K = K, S = S, strat = strat, factor.time = factor.time, user.allocs = user.allocs, design = design)
XMat = Design_out$XMat
size = Design_out$size
if (family == "gaussian") {
Ve <- diag(1, nrow = sum(size))
Vclus <- lapply(1:sum(I), FUN = function(clus) {
matrix(1, nrow = size[clus], ncol = size[clus])
})
Vclus <- bdiag(Vclus)
VV <- as.matrix(sigma.e^2 * Ve + sigma.a^2 * Vclus)
# power calculation
power <- sapply(XMat, FUN = function(XMat_i) {
VarTx <- solve(t(XMat_i) %*% solve(VV) %*% XMat_i)[1, 1]
pnorm(Tx.effect/sqrt(VarTx) - qnorm(1 - sig.level/2), lower.tail = T) +
pnorm(-Tx.effect/sqrt(VarTx) - qnorm(1 - sig.level/2),
lower.tail = T)
})
}
if (family == "binomial") {
# only AML has been implemented for binary outcome
b0 <- log(mu0/(1 - mu0)) # baseline risk
b1 <- log(Tx.effect) # log(OR)
if (is.null(Time.effect)) # if Time.effect is not specified:
if (factor.time) b2 <- 0 * b1 * c(1:J) else # when time is categorical, default values are equivalent to continuous time ???
b2 <- 0 * b1 # default is half of treatment effect when time is continuous
else { # f Time.effect is specified:
if (factor.time) {
if (length(Time.effect) != (J)) stop("length of Time.effect should match the number of transition steps")
} else {
if (length(Time.effect) != 1) stop("Time.effect should have length 1 when time is a continuous covariate")
}
b2 <- Time.effect
}
power <- sapply(XMat, FUN = function(XMat_i) {
vec_pi <- as.vector(1 + exp(-(XMat_i %*% c(b1, b0, b2))))^(-1)
clus.id <- split(1:sum(size), rep(1:sum(I), size))
FIM <- lapply(1:sum(I), FUN = function(ii) {
VClus <- matrix(1, nrow = size[ii], ncol = size[ii])
WWi_inv <- solve(diag(vec_pi[clus.id[[ii]]] * (1 - vec_pi[clus.id[[ii]]])))
VV <- WWi_inv + sigma.a^2 * VClus
t(XMat_i[clus.id[[ii]], ]) %*% solve(VV) %*% XMat_i[clus.id[[ii]],
]
})
FIM <- Reduce("+", FIM)
VarTx <- solve(FIM)[1, 1]
pnorm(b1/sqrt(VarTx) - qnorm(1 - sig.level/2), lower.tail = T) +
pnorm(-b1/sqrt(VarTx) - qnorm(1 - sig.level/2), lower.tail = T)
})
}
if (family == "poisson") {
# only AML has been implemented for count outcome
b0 <- log(mu0) # baseline rate
b1 <- log(Tx.effect) # log(RR)
if (is.null(Time.effect)) # if Time.effect is not specified:
if (factor.time) b2 <- 0 * c(1:J) else # when time is categorical, default is ???
b2 <- 0 * b1 # default is half of treatment effect when time is continuous
else { # f Time.effect is specified:
if (factor.time) {
if (length(Time.effect) != (J)) stop("length of 'Time.effect should match the number of transition steps")
} else {
if (length(Time.effect) != 1) stop("Time.effect should have length 1 when time is a continuous covariate")
}
b2 <- Time.effect
}
power <- sapply(XMat, FUN = function(XMat_i) {
vec_lambda <- as.vector(exp(XMat_i %*% c(b1, b0, b2)))
clus.id <- split(1:sum(size), rep(1:sum(I), size))
FIM <- lapply(1:sum(I), FUN = function(ii) {
VClus <- matrix(1, nrow = size[ii], ncol = size[ii])
WWi_inv <- solve(diag(vec_lambda[clus.id[[ii]]]))
VV <- WWi_inv + sigma.a^2 * VClus
t(XMat_i[clus.id[[ii]], ]) %*% solve(VV) %*% XMat_i[clus.id[[ii]],
]
})
FIM <- Reduce("+", FIM)
VarTx <- solve(FIM)[1, 1]
pnorm(b1/sqrt(VarTx) - qnorm(1 - sig.level/2), lower.tail = T) +
pnorm(-b1/sqrt(VarTx) - qnorm(1 - sig.level/2), lower.tail = T)
})
}
power
}
}
power.rep = matrix(power.rep, nrow=1)
power.mean = apply(power.rep, 2, mean)
if (is.null(user.allocs)){
if (strat){
all_allocs_out =  all_allocs_strat(I=I, P=P, S=S, K=K)
} else {
all_allocs_out = all_allocs(I=I, J=J, P=P)
}
wgh = all_allocs_out$weights
allocs = all_allocs_out$order
final.data <- data.frame(weight = c(wgh),
power = c(power.mean))
final.data1 <- final.data[order(final.data$power),]
risk <- sum(final.data1$weight[which(final.data1$power <= pwr.thrd)])
if (is.null(pwr.thrd)){
risk <- NULL
}
if (plot == TRUE){
print(ggplot(final.data, aes(x = power, y = ..density.., weight = weight)) +
geom_histogram(binwidth = 0.01, fill = "blue") + ggtitle("Power distribution (Analytic-based)"))
}
} else {
allocs <- user.allocs
wgh <- NULL
risk <- NULL}
if (design == "sw") return(list(attained.power.analytic=power.mean, PREP.analytic = sum(power.mean*wgh), CV = CV, PREP.CV= power.CV, allocations = allocs, risk.analytic = risk))
#if (design == "sw" & !is.null(user.allocs)) return(list(attained.power.analytic=power.mean, CV = CV, PREP.CV= power.CV, allocations = allocs, risk.analytic = risk))
if (design == "pcrt")  return(list(attained.power.analytic=power.mean, PREP.analytic = sum(power.mean*wgh), CV = CV, PREP.CV= power.CV, allocations = allocs, risk.analytic = risk))
#if (design == "pcrt" & !is.null(user.allocs))  return(list(attained.power.analytic=power.mean, CV = CV, PREP.CV= power.CV, allocations = allocs, risk.analytic = risk))
}
sim.ap <- compiler::cmpfun(sim.ap)
sim.pd <- compiler::cmpfun(sim.pd)
sim.strata.pd <- compiler::cmpfun(sim.strata.pd)
siglevel <- compiler::cmpfun(siglevel)
analytic.pd <- compiler::cmpfun(analytic.pd)
## ---------------------------------------------------
## Main functions and wrapper function to combine
## above functions
## ---------------------------------------------------
power.pd <- function(I, P, K, mu0, Tx.effect, Time.effect = NULL, pwr.thrd = NULL, factor.time = TRUE,
design, rho = NULL, family, sig.level = 0.05,
sigma.e = NULL, sigma.a = NULL, method = "analytic",
plot = FALSE, gen.all = TRUE, n.allocs,  n.sims, seed = NULL){
n.cores <- parallel::detectCores()
doParallel::registerDoParallel(cores=n.cores-1)
if (!is.null(seed)){
set.seed(seed)
}
if (method == "analytic"){
gen.all = NULL; n.allocs = NULL;  n.sims = NULL
res <- analytic.pd (I = I, P = P, K = K, pwr.thrd = pwr.thrd, factor.time = factor.time,
mu0 = mu0, Tx.effect = Tx.effect, Time.effect = Time.effect, rho = rho, family = family, plot = plot,
design = design, sig.level = sig.level, sigma.e = sigma.e, sigma.a = sigma.a)
}
if (method == "sim"){
res <- sim.pd (I = I, P = P, K = K, mu0 = mu0, Tx.effect = Tx.effect, Time.effect = Time.effect, pwr.thrd = pwr.thrd, factor.time = factor.time,
design = design, gen.all = gen.all, n.allocs = n.allocs,  n.sims = n.sims, rho = rho,
sigma.e = sigma.e, sigma.a = sigma.a, print.allocs = TRUE, plot = plot, sig.level = sig.level,
family = family)
}
if (method == "both"){
res <- sim.pd (I = I, P = P, K = K, mu0 = mu0, Tx.effect = Tx.effect, Time.effect = Time.effect, pwr.thrd = pwr.thrd, factor.time = factor.time,
design = design, gen.all = gen.all, n.allocs = n.allocs,  n.sims = n.sims, rho = rho,
sigma.e = sigma.e, sigma.a = sigma.a, print.allocs = TRUE, plot = plot, sig.level = sig.level,
family = family)
res1 <- analytic.pd (I = I, P = P, K = K, user.allocs = res$allocation, pwr.thrd = pwr.thrd, factor.time = factor.time,
mu0 = mu0, Tx.effect = Tx.effect, Time.effect = Time.effect, rho = rho, family = family, plot = plot,
design = design, sig.level = sig.level, sigma.e = sigma.e, sigma.a = sigma.a)
allocs <- res$allocation
wgh <- res$weights
final.data <- data.frame(weight = c(wgh),
power = c(res1$attained.power))
final.data1 <- final.data[order(final.data$power),]
risk <- sum(final.data1$weight[which(final.data1$power <= pwr.thrd)])
if (is.null(pwr.thrd)){
risk <- NULL
}
res1$risk.analytic <- risk
res1$allocations <- NULL
### Redefine PREP in case only part of it has been evaulated
res1$PREP.analytic <- sum(res1$attained.power.analytic*(wgh/sum(wgh)))
}
if(method =="both") {return(list(results = c(res, res1), inputs = list(I = I, P = P, K = K, mu0 = mu0, Tx.effect = Tx.effect, Time.effect = Time.effect, pwr.thrd = pwr.thrd, factor.time = factor.time,
design = design, gen.all = gen.all, n.allocs = n.allocs,  n.sims = n.sims, rho = rho,
sigma.e = sigma.e, sigma.a = sigma.a, plot = plot, sig.level = sig.level,
family = family)))} else {return(list(results = res, inputs = list(I = I, P = P, K = K, mu0 = mu0, Tx.effect = Tx.effect, Time.effect = Time.effect, pwr.thrd = pwr.thrd, factor.time = factor.time,
design = design, gen.all = gen.all, n.allocs = n.allocs,  n.sims = n.sims, rho = rho,
sigma.e = sigma.e, sigma.a = sigma.a, plot = plot, sig.level = sig.level,
family = family)))}
}
power.ap <- function(I, P , K , mu0, Tx.effect, Time.effect = NULL, user.allocs , factor.time = TRUE,
family, design, rho = NULL, sigma.e = NULL, sigma.a = NULL, sig.level = 0.05,
method = "analytic", adj.pwr=FALSE,
seed = NULL, n.sims = 1000){
n.cores <- parallel::detectCores()
doParallel::registerDoParallel(cores=n.cores-1)
if (adj.pwr == TRUE){
if (method == "analytic" | method == "both"){stop("Adjust for Type I error only works when Method = 'sim'")}
if (!is.null(seed)){
set.seed(seed)
}
if (family != "gaussian"){Tx = 1} else {Tx = 0}
temp <- siglevel(I = I, P = P, K = K, user.allocs = user.allocs, mu0 = mu0, Tx.effect = Tx, Time.effect = Time.effect,
factor.time = factor.time, design = design, n.sims = n.sims, rho = rho,
sigma.e = sigma.e, sigma.a = sigma.a, sig.level = sig.level,
family = family)
sig <- temp
} else {sig <- sig.level}
if (method == "analytic"){
n.sims = NULL
if (!is.null(seed)){
set.seed(seed)
}
res <- analytic.pd (I = I, P = P, K = K, user.allocs = user.allocs, pwr.thrd = pwr.thrd, factor.time = factor.time,
mu0 = mu0, Tx.effect = Tx.effect, Time.effect = Time.effect, rho = rho, family = family, plot = F,
design = design, sig.level = sig, sigma.e = sigma.e, sigma.a = sigma.a)
res$PREP.CV <- NULL
res$allocations <- NULL
res$risk.analytic <- NULL
res$PREP.analytic <- NULL
}
if (method == "sim"){
if (!is.null(seed)){
set.seed(seed)
}
res <- sim.ap (I = I, P = P, K = K, user.allocs = user.allocs, mu0 = mu0, Tx.effect = Tx.effect, Time.effect = Time.effect, factor.time = factor.time,
design = design, n.sims = n.sims, rho = rho,
sigma.e = sigma.e, sigma.a = sigma.a, sig.level = sig,
family = family)
}
if (method == "both"){
if (!is.null(seed)){
set.seed(seed)
}
res <- sim.ap (I = I, P = P, K = K, user.allocs = user.allocs, mu0 = mu0, Tx.effect = Tx.effect, Time.effect = Time.effect, factor.time = factor.time,
design = design, n.sims = n.sims, rho = rho,
sigma.e = sigma.e, sigma.a = sigma.a, sig.level = sig,
family = family)
res1 <- analytic.pd (I = I, P = P, K = K, user.allocs = user.allocs, pwr.thrd = pwr.thrd, factor.time = factor.time,
mu0 = mu0, Tx.effect = Tx.effect, Time.effect = Time.effect, rho = rho, family = family, plot = F,
design = design, sig.level = sig, sigma.e = sigma.e, sigma.a = sigma.a)
res1$PREP.CV <- NULL
res1$allocations <- NULL
res1$risk.analytic <- NULL
res1$PREP.analytic <- NULL
}
if(method =="both") {return(list(results = c(res,res1), inputs = list(I = I, P = P, K = K, user.allocs = user.allocs, mu0 = mu0, Tx.effect = Tx.effect, Time.effect = Time.effect, factor.time = factor.time,
design = design, n.sims = n.sims, rho = rho,
sigma.e = sigma.e, sigma.a = sigma.a, sig.level = sig.level,
family = family)))} else {return(list(results = res, inputs = list(I = I, P = P, K = K, user.allocs = user.allocs, mu0 = mu0, Tx.effect = Tx.effect, Time.effect = Time.effect, factor.time = factor.time,
design = design, n.sims = n.sims, rho = rho,
sigma.e = sigma.e, sigma.a = sigma.a, sig.level = sig.level,
family = family)))}
}
power.strat.pd <- function(I, P , K , S , mu0, Tx.effect, Time.effect = NULL, pwr.thrd = NULL,
factor.time = TRUE, rho = NULL, family, design, gen.all = TRUE, n.allocs,
n.sims, sig.level = 0.05, plot = FALSE, seed = NULL,
sigma.e = NULL, sigma.a = NULL, method = "analytic"){
n.cores <- parallel::detectCores()
doParallel::registerDoParallel(cores=n.cores-1)
if (!is.null(seed)){
set.seed(seed)
}
if (method == "analytic"){
gen.all = NULL; n.allocs = NULL; n.sims = NULL
res <- analytic.pd (I = I, P = P, K = K, S = S, pwr.thrd = pwr.thrd, factor.time = factor.time,
mu0 = mu0, Tx.effect = Tx.effect, Time.effect = Time.effect, rho = rho, family = family, plot =plot,
design = design, sig.level = sig.level, sigma.e = sigma.e, sigma.a = sigma.a)
res$PREP.CV <- NULL
}
if (method == "sim"){
res <- sim.strata.pd (I = I, P = P, K = K, S = S, mu0 = mu0, Tx.effect = Tx.effect, Time.effect = Time.effect, pwr.thrd = pwr.thrd, factor.time = factor.time,
design = design, gen.all = gen.all, n.allocs = n.allocs, n.sims = n.sims, rho = rho,
sigma.e = sigma.e, sigma.a = sigma.a, print.allocs = TRUE, plot = plot, sig.level = sig.level,
family = family)
}
if (method == "both"){
res <- sim.strata.pd (I = I, P = P, K = K, S = S, mu0 = mu0, Tx.effect = Tx.effect, Time.effect = Time.effect, pwr.thrd = pwr.thrd, factor.time = factor.time,
design = design, gen.all = gen.all, n.allocs = n.allocs,  n.sims = n.sims, rho = rho,
sigma.e = sigma.e, sigma.a = sigma.a, print.allocs = TRUE, plot = plot, sig.level = sig.level,
family = family)
res1 <- analytic.pd (I = I, P = P, K = K, S = S, user.allocs = res$allocation, pwr.thrd = pwr.thrd, factor.time = factor.time,
mu0 = mu0, Tx.effect = Tx.effect, Time.effect = Time.effect, rho = rho, family = family, plot = plot,
design = design, sig.level = sig.level, sigma.e = sigma.e, sigma.a = sigma.a  )
allocs <- res$allocation
wgh <- res$weights
final.data <- data.frame(weight = c(wgh),
power = c(res1$attained.power))
final.data1 <- final.data[order(final.data$power),]
risk <- sum(final.data1$weight[which(final.data1$power <= pwr.thrd)])
if (is.null(pwr.thrd)){
risk <- NULL
}
res1$risk.analytic <- risk
res1$PREP <- NULL
res1$allocations <- NULL
res1$PREP.analytic <- sum(res1$attained.power.analytic*(wgh/sum(wgh)))
}
if(method =="both") {return(list(results = list(simres = res, analyticres = res1), inputs = list(I = I, P = P, K = K, S = S, mu0 = mu0, Tx.effect = Tx.effect, Time.effect = Time.effect, pwr.thrd = pwr.thrd, factor.time = factor.time,
design = design, gen.all = gen.all, n.allocs = n.allocs, n.sims = n.sims, rho = rho,
sigma.e = sigma.e, sigma.a = sigma.a, plot = plot, sig.level = sig.level,
family = family)))} else {return(list(results = res, inputs = list(I = I, P = P, K = K, S = S, mu0 = mu0, Tx.effect = Tx.effect, Time.effect = Time.effect, pwr.thrd = pwr.thrd, factor.time = factor.time,
design = design, gen.all = gen.all, n.allocs = n.allocs, n.sims = n.sims, rho = rho,
sigma.e = sigma.e, sigma.a = sigma.a, print.allocs = TRUE, plot = plot, sig.level = sig.level,
family = family)))}
}
power.ap <- compiler::cmpfun(power.ap)
power.pd <- compiler::cmpfun(power.pd)
power.strat.pd <- compiler::cmpfun(power.strat.pd)
siglevel <- compiler::cmpfun(siglevel)
require(arrangements)
require(doParallel)
require(parallel)
require(lme4)
require(ggplot2)
require(doRNG)
require(compiler)
library(lme4)
install.packages("lme4")
library(lme4)
remove.packages("lme4")
install.packages("lme4")
library(lme4)
data = read.csv("../Downloads/Direct Messages - Private - Vi [860192840457519114].csv")
head(data)
unique(data$AuthorID))
unique(data$AuthorID)
data$AuthorID = factor(levels = c(unique(data$AuthorID)), labels = c("babe", "me"))
data$AuthorID = factor(levels = unique(data$AuthorID), labels = c("babe", "me"))
data$AuthorID = factor(x = data$AuthorID, levels = unique(data$AuthorID), labels = c("babe", "me"))
data$AuthorID
head(data)
data$Date
data$Date[1]
now
table(data$AuthorID)
nchar(data$Content[1])
data$Content
class(data$Content)
data
data$Attachments
data$content_sting = as.character(data$Content)
data$content_sting[1]
data$content_sting = as.character(data$Content)
data$nchar = nchar(data$content_sting)
data$nchar
split(data, data$AuthorID)
temp = split(data, data$AuthorID)
sapply(temp, function(x){mean(x$nchar}))
temp[[1]]
temp[[1]]$nchar
sapply(temp, function(x){mean(x$nchar)})
data[,c("AuthorID", "nchar")]
data = read.csv("../Downloads/Direct Messages - Private - DeletedUser [851627389325672468].csv")
head(data)
data$AuthorID = factor(x = data$AuthorID, levels = unique(data$AuthorID), labels = c("babe", "me"))
data$content_sting = as.character(data$Content)
data$nchar = nchar(data$content_sting)
temp = split(data, data$AuthorID)
sapply(temp, function(x){mean(x$nchar)})
data$AuthorID = factor(x = data$AuthorID, levels = unique(data$AuthorID), labels = c("peach", "me"))
data$content_sting = as.character(data$Content)
data$nchar = nchar(data$content_sting)
temp = split(data, data$AuthorID)
sapply(temp, function(x){mean(x$nchar)})
table(data$AuthorID)
data = read.csv("../Downloads/Direct Messages - Private - Vi [860192840457519114].csv")
data$AuthorID = factor(x = data$AuthorID, levels = unique(data$AuthorID), labels = c("babe", "me"))
data$content_sting = as.character(data$Content)
data$nchar = nchar(data$content_sting)
temp = split(data, data$AuthorID)
sapply(temp, function(x){mean(x$nchar)})
table(data$AuthorID)
data$Date[1]-data$Date[2]
data$Reactions
today()
now()
ymd("2017-01-31")
data$Date[1]
library(tidyverse)
data$Date[1]
today()
data = read.csv("../Downloads/Direct Messages - Private - Vi [860192840457519114].csv")
data$AuthorID = factor(x = data$AuthorID, levels = unique(data$AuthorID), labels = c("babe", "me"))
data$content_sting = as.character(data$Content)
data$nchar = nchar(data$content_sting)
temp = split(data, data$AuthorID)
sapply(temp, function(x){mean(x$nchar)})
table(data$AuthorID)
setwd("~/../LX_Project/cart/rhc/")
