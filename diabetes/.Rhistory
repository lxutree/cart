}) / nrow(data.gini))
# checking size of children nodes; if less than specified, the split is not considered
count_min = min(sapply(data.gini.list, nrow))
if(count_min < round(leafsize)) gini_splits[k-1] = NA
}
}
# calculating sse for all possible splits
# clean up for when none of the splits is valid:
if(all(is.na(gini_splits))) {
gini[i] = NA
min_split[i] = NA
} else {
gini[i] = min(gini_splits, na.rm = TRUE)
min_split[i] = splits_sort[which.min(gini_splits)]}
}
}
# characteristics of the current split
split.var = feat[which.min(gini)] # feature leading to the lowest gini index
gini_diff = gini_parent - min(gini, na.rm = TRUE) # difference in gini index
feat_vec = c(feat_vec, split.var) # recorded in vector
gini_vec = c(gini_vec, gini_diff) # recorded in vector
# creating children nodes by the selected feature:
if( is.factor(data.temp[[split.var]]) ) {
# for categorical feature:
data.next = split(data.temp, data.temp[ , split.var])
} else {
# for continuous feature:
split.val = min_split[which.min(gini)]
index = which(sort(unique(data.temp[[split.var]])) == split.val)
# taking the middle point of unique values as the splitting point to be consistent with 'rpart':
split.val = (sort(unique(data.temp[[split.var]]))[index] + sort(unique(data.temp[[split.var]]))[index+1])/2
data.next = list()
data.next[[1]] = data.temp[which(data.temp[[split.var]] <= split.val), ]
data.next[[2]] = data.temp[which(data.temp[[split.var]] > split.val), ]
}
# Stopping criteria:
# - less than 3 observations
# - all observations have the same label
status = sapply(data.next, function(x){
if (ncol(data.frame(x)) == 1 | length(unique(x[[resp]])) == 1 ) status = "leaf" else {
if (nrow(x) < min.obs | nrow( unique(data.frame(x[, -which(names(x) %in% resp)])) ) == 1) status = "leaf" else status = "split"
}
status
})
# change current status from 'split' to 'parent' so it won't be split further:
output$status[j] = "parent"
# record how the split was done:
split_rule =  if( is.factor(data.temp[[split.var]]) ) {
sapply(names(data.next), function(x){paste(split.var, "=" , x)})
} else {
c(paste(split.var, " <= ", split.val),  paste(split.var, " > ", split.val))
}
# attach new outputs to existing dataframe
temp.output = data.frame(status = status, count = sapply(data.next, function(x) nrow(data.frame(x))), "split rule" = split_rule, "response" = paste(levels(data[[resp]])[1], ":", sapply(data.next, function(x){ table(x[[resp]])[1]}), "/", sapply(data.next,nrow)), prob = sapply(data.next, function(x){ table(x[[resp]])[1]}) / sapply(data.next,nrow), iter = output$iter[j] + 1, row.names = NULL)
output = rbind(output[1:j,], temp.output, output[-c(1:j), ])
names(data.next) = NULL; data.list = c(data.list[1:j], data.next, data.list[-c(1:j)])
}
# check if there are remaining splits to be done:
if(all(output$status != "split")) stopsplit = TRUE
# to control the depth of the tree:
if(!is.null(depth)) {if (length(feat_vec) + 1 >= depth) stopsplit = TRUE  }
}
# summing up gini index differences for each feature
gini_sum = c()
for (i in 1:length(allfeat)){
gini_sum[i] = sum(gini_vec[which(feat_vec == allfeat[i])])
}
return(list(output = output, var_rank = data.frame(criterion = gini_sum, row.names = allfeat)))
}
# function to generate predictions based on given tree
predtree = function(newdata, resp, res, data){
# splitting rules from tree:
rules = data.frame(t(sapply(res$split.rule[-1 ], function(x){scan(text = x, what = "" , quiet = TRUE, )}, USE.NAMES = FALSE)), res$iter[-1], stringsAsFactors = FALSE)
names(rules) = c("feat", "operator", "value", "iter")
for(k in 1:nrow(newdata)){
ii=1
stoploop = FALSE
while(!stoploop){
if(compare(newdata[k, rules[ii, "feat"]], rules[ii, "value"],  (rules[ii, "operator"]))) {
if(rules$iter[ii+1] == rules$iter[ii]) stoploop = TRUE else ii = ii + 1
} else {
ii = which(rules$feat == rules$feat[ii] & rules$iter == rules$iter[ii])[which(rules$feat == rules$feat[ii] & rules$iter == rules$iter[ii]) > ii][1]
}
if(rules$iter[ii+1] < rules$iter[ii] | ii == nrow(rules)) stoploop = TRUE
}
if(class(data[, resp]) == "factor"){
newdata[,resp][k] = if(res$prob[ii+1] > 0.5) levels(data[, resp])[1] else { if(res$prob[ii+1] == 0.5) levels(data[, resp])[sample(x = 2, size = 1, prob = c(0.5, 0.5))] else levels(data[, resp])[2]}
} else {
newdata[,resp][k] = res$mean[ii+1]
}
}
return(newdata)
}
# helper function:
compare = function(x1,value, operator){
if(operator == "=") operator = "=="
if(!is.na(suppressWarnings(as.numeric(value)))) value = as.numeric(value)
res = getFunction(operator)(x1,value); res }
na.omit.list <- function(y) { return(y[!sapply(y, function(x) all(is.na(x)))]) }
# this function calculates the out of bag error based on predictions using the vaues of features in 'newdata'
ooberror = function(newdata){
# compute predictions for each obs in the dataset
for (obs in 1:nrow(data)){
# for obs i, gather list of trees that weren't built from this obs
# only those trees will be used to predict
ifoob = sapply(index_list, function(index){
!(obs %in% index)
})
if(class(data[, resp]) == "factor"){
# for classification:
pred_obs = lapply(1:length(tree_list), function(k){
# generate prediction from tree k if it didn't contain current obs
if(ifoob[k] == TRUE) data.frame(resp = predtree(newdata = newdata[obs, ], resp = resp, res = tree_list[[k]]$output, data = data)[,resp]) else NA
})
pred_obs = na.omit.list(pred_obs)
pred_obs = do.call(rbind, pred_obs)
# if no prediction was generated from any tree, set to NA
if(is.null(pred_obs)) pred[obs] = NA else{
# other wise, find the majority vote
pred[obs] = if(table(pred_obs)[1] != table(pred_obs)[2]){
levels(pred_obs$resp)[which.max(table(pred_obs))]
} else {
# If there's no majority, pick randomly with equal probabilities
levels(pred_obs$resp)[sample(x = 2, size = 1, prob = c(0.5, 0.5))]
}
}
} else {
# for regression:
# generate prediction from tree k if it didn't contain current obs
pred_obs = sapply(1:length(tree_list), function(k){
if(ifoob[k] == TRUE) predtree(newdata = newdata[obs, ], resp = resp, res = tree_list[[k]]$output, data = data)[,resp] else NA
})
# if no prediction was generated from any tree, set to NA. Otherwise, compute the average of predictions
if (all(is.na(pred_obs))) pred[obs] = NA else pred[obs]  = mean(pred_obs, na.rm = TRUE)
}
}
if(class(data[, resp]) == "factor"){
# dataframe containing predicted and observed values:
comb = data.frame(pred, observed = data[,resp])
comb = na.omit(comb)
# find the rate of missclassification for classification trees:
error = mean(comb$pred != comb$observed)
} else {
# compute rmse for regression trees:
error = sqrt(mean( (pred - data[,resp])^2, na.rm = TRUE))
}
return(error)
}
classtree(data = data_test, resp = "readmitted", depth = 2,)
classtree(data = data_test, resp = "readmitted", depth = 2, min.obs = 100)
classtree(data = data_test, resp = "readmitted", min.obs = 100)
na.omit(data_test)
data_test
which(data_test) == "?"
which(data_test == "?")
classtree(data = data_test, resp = "readmitted", min.obs = 100)
data = data_test
resp = "readmitted"
min.obs = 100
feat = NULL
nfeat = NULL
type = NULL
depth = NULL
# minimum size of leaves?
leafsize = min.obs/3 # same as the default in rpart
# data.frame to store results:
output = data.frame(status = "split", count = nrow(data), "split rule" = "root", "response" = paste(levels(data[[resp]])[1], ":", table(data[[resp]])[1] , "/",nrow(data)), iter = 0, prob =  table(data[[resp]])[1]/nrow(data), stringsAsFactors = FALSE)
# list of observations in each node/leaf:
data.list = list()
# data at the root:
data.list[[1]] = data
# indicator for whether the tree keeps growing:
stopsplit = FALSE
# list of features:
if(is.null(feat)) feat = allfeat = names(data)[names(data)!=resp]
if(is.null(nfeat)) nfeat = round(sqrt(length(feat)))
# vector of features/gini index reduction for each split:
feat_vec = c()
gini_vec = c()
# list of splits to be done:
split.queue = which(output$status == "split")
split.queue
j=1
# empty vector for gini index:
gini=c()
min_split = c()
data.temp = data.list[[j]]
# for random forrest
if(!is.null(type)){if(type == "rf") feat = sample(allfeat, size = nfeat, replace = FALSE)}
# calculating gini index:
for (i in 1:length(feat)){
data.gini = data.frame(var = data.temp[, feat[i]], resp = data.temp[, resp])
# gini index of parent node
count = table(data.gini)
gini_parent = 1 - sum((count / sum(count)) ^ 2)
# calculating sse for categorical feature:
if( is.factor(data.gini$var) ) {
data.gini.list = split(data.gini, data.gini$var)
gini[i] = sum(sapply(data.gini.list, function(x){
count = table(x)
gini = 1 - sum((count / sum(count)) ^ 2)
gini * sum(count)
}) / nrow(data.gini))
# checking size of children nodes; if less than specified, the split is not considered
count_min = min(sapply(data.gini.list, nrow))
if( count_min < leafsize) gini[i] = NA
} else {
# calculating gini index for continuous feature:
gini_splits = c()
splits_sort = sort(unique(data.gini$var))
if (length(unique(splits_sort)) < 2) {gini[i] = NA; min_split[i] = NA}
else {
for( k in 2:length(splits_sort)){
data.gini = data.frame(var = data.temp[, feat[i]], data.temp[, resp])
data.gini$var = cut(data.gini$var, breaks =c(splits_sort[1],mean(c(splits_sort[k-1], splits_sort[k])), max(splits_sort)+1 ), right=FALSE)
data.gini.list = split(data.gini, data.gini$var)
gini_splits[k-1] = sum(sapply(data.gini.list, function(x){
count = table(x)
gini = 1 - sum((count / sum(count)) ^ 2)
gini * sum(count)
}) / nrow(data.gini))
# checking size of children nodes; if less than specified, the split is not considered
count_min = min(sapply(data.gini.list, nrow))
if(count_min < round(leafsize)) gini_splits[k-1] = NA
}
}
# calculating sse for all possible splits
# clean up for when none of the splits is valid:
if(all(is.na(gini_splits))) {
gini[i] = NA
min_split[i] = NA
} else {
gini[i] = min(gini_splits, na.rm = TRUE)
min_split[i] = splits_sort[which.min(gini_splits)]}
}
}
# characteristics of the current split
split.var = feat[which.min(gini)] # feature leading to the lowest gini index
gini_diff = gini_parent - min(gini, na.rm = TRUE) # difference in gini index
feat_vec = c(feat_vec, split.var) # recorded in vector
gini_vec = c(gini_vec, gini_diff) # recorded in vector
# creating children nodes by the selected feature:
if( is.factor(data.temp[[split.var]]) ) {
# for categorical feature:
data.next = split(data.temp, data.temp[ , split.var])
} else {
# for continuous feature:
split.val = min_split[which.min(gini)]
index = which(sort(unique(data.temp[[split.var]])) == split.val)
# taking the middle point of unique values as the splitting point to be consistent with 'rpart':
split.val = (sort(unique(data.temp[[split.var]]))[index] + sort(unique(data.temp[[split.var]]))[index+1])/2
data.next = list()
data.next[[1]] = data.temp[which(data.temp[[split.var]] <= split.val), ]
data.next[[2]] = data.temp[which(data.temp[[split.var]] > split.val), ]
}
# Stopping criteria:
# - less than 3 observations
# - all observations have the same label
status = sapply(data.next, function(x){
if (ncol(data.frame(x)) == 1 | length(unique(x[[resp]])) == 1 ) status = "leaf" else {
if (nrow(x) < min.obs | nrow( unique(data.frame(x[, -which(names(x) %in% resp)])) ) == 1) status = "leaf" else status = "split"
}
status
})
# change current status from 'split' to 'parent' so it won't be split further:
output$status[j] = "parent"
# record how the split was done:
split_rule =  if( is.factor(data.temp[[split.var]]) ) {
sapply(names(data.next), function(x){paste(split.var, "=" , x)})
} else {
c(paste(split.var, " <= ", split.val),  paste(split.var, " > ", split.val))
}
# attach new outputs to existing dataframe
temp.output = data.frame(status = status, count = sapply(data.next, function(x) nrow(data.frame(x))), "split rule" = split_rule, "response" = paste(levels(data[[resp]])[1], ":", sapply(data.next, function(x){ table(x[[resp]])[1]}), "/", sapply(data.next,nrow)), prob = sapply(data.next, function(x){ table(x[[resp]])[1]}) / sapply(data.next,nrow), iter = output$iter[j] + 1, row.names = NULL)
output = rbind(output[1:j,], temp.output, output[-c(1:j), ])
names(data.next) = NULL; data.list = c(data.list[1:j], data.next, data.list[-c(1:j)])
# check if there are remaining splits to be done:
if(all(output$status != "split")) stopsplit = TRUE
# to control the depth of the tree:
if(!is.null(depth)) {if (length(feat_vec) + 1 >= depth) stopsplit = TRUE  }
# iterative process:
while(!stopsplit) {
# list of splits to be done:
split.queue = which(output$status == "split")
for (j in split.queue[1]) {
# empty vector for gini index:
gini=c()
min_split = c()
data.temp = data.list[[j]]
# for random forrest
if(!is.null(type)){if(type == "rf") feat = sample(allfeat, size = nfeat, replace = FALSE)}
# calculating gini index:
for (i in 1:length(feat)){
data.gini = data.frame(var = data.temp[, feat[i]], resp = data.temp[, resp])
# gini index of parent node
count = table(data.gini)
gini_parent = 1 - sum((count / sum(count)) ^ 2)
# calculating sse for categorical feature:
if( is.factor(data.gini$var) ) {
data.gini.list = split(data.gini, data.gini$var)
gini[i] = sum(sapply(data.gini.list, function(x){
count = table(x)
gini = 1 - sum((count / sum(count)) ^ 2)
gini * sum(count)
}) / nrow(data.gini))
# checking size of children nodes; if less than specified, the split is not considered
count_min = min(sapply(data.gini.list, nrow))
if( count_min < leafsize) gini[i] = NA
} else {
# calculating gini index for continuous feature:
gini_splits = c()
splits_sort = sort(unique(data.gini$var))
if (length(unique(splits_sort)) < 2) {gini[i] = NA; min_split[i] = NA}
else {
for( k in 2:length(splits_sort)){
data.gini = data.frame(var = data.temp[, feat[i]], data.temp[, resp])
data.gini$var = cut(data.gini$var, breaks =c(splits_sort[1],mean(c(splits_sort[k-1], splits_sort[k])), max(splits_sort)+1 ), right=FALSE)
data.gini.list = split(data.gini, data.gini$var)
gini_splits[k-1] = sum(sapply(data.gini.list, function(x){
count = table(x)
gini = 1 - sum((count / sum(count)) ^ 2)
gini * sum(count)
}) / nrow(data.gini))
# checking size of children nodes; if less than specified, the split is not considered
count_min = min(sapply(data.gini.list, nrow))
if(count_min < round(leafsize)) gini_splits[k-1] = NA
}
}
# calculating sse for all possible splits
# clean up for when none of the splits is valid:
if(all(is.na(gini_splits))) {
gini[i] = NA
min_split[i] = NA
} else {
gini[i] = min(gini_splits, na.rm = TRUE)
min_split[i] = splits_sort[which.min(gini_splits)]}
}
}
# characteristics of the current split
split.var = feat[which.min(gini)] # feature leading to the lowest gini index
gini_diff = gini_parent - min(gini, na.rm = TRUE) # difference in gini index
feat_vec = c(feat_vec, split.var) # recorded in vector
gini_vec = c(gini_vec, gini_diff) # recorded in vector
# creating children nodes by the selected feature:
if( is.factor(data.temp[[split.var]]) ) {
# for categorical feature:
data.next = split(data.temp, data.temp[ , split.var])
} else {
# for continuous feature:
split.val = min_split[which.min(gini)]
index = which(sort(unique(data.temp[[split.var]])) == split.val)
# taking the middle point of unique values as the splitting point to be consistent with 'rpart':
split.val = (sort(unique(data.temp[[split.var]]))[index] + sort(unique(data.temp[[split.var]]))[index+1])/2
data.next = list()
data.next[[1]] = data.temp[which(data.temp[[split.var]] <= split.val), ]
data.next[[2]] = data.temp[which(data.temp[[split.var]] > split.val), ]
}
# Stopping criteria:
# - less than 3 observations
# - all observations have the same label
status = sapply(data.next, function(x){
if (ncol(data.frame(x)) == 1 | length(unique(x[[resp]])) == 1 ) status = "leaf" else {
if (nrow(x) < min.obs | nrow( unique(data.frame(x[, -which(names(x) %in% resp)])) ) == 1) status = "leaf" else status = "split"
}
status
})
# change current status from 'split' to 'parent' so it won't be split further:
output$status[j] = "parent"
# record how the split was done:
split_rule =  if( is.factor(data.temp[[split.var]]) ) {
sapply(names(data.next), function(x){paste(split.var, "=" , x)})
} else {
c(paste(split.var, " <= ", split.val),  paste(split.var, " > ", split.val))
}
# attach new outputs to existing dataframe
temp.output = data.frame(status = status, count = sapply(data.next, function(x) nrow(data.frame(x))), "split rule" = split_rule, "response" = paste(levels(data[[resp]])[1], ":", sapply(data.next, function(x){ table(x[[resp]])[1]}), "/", sapply(data.next,nrow)), prob = sapply(data.next, function(x){ table(x[[resp]])[1]}) / sapply(data.next,nrow), iter = output$iter[j] + 1, row.names = NULL)
output = rbind(output[1:j,], temp.output, output[-c(1:j), ])
names(data.next) = NULL; data.list = c(data.list[1:j], data.next, data.list[-c(1:j)])
}
# check if there are remaining splits to be done:
if(all(output$status != "split")) stopsplit = TRUE
# to control the depth of the tree:
if(!is.null(depth)) {if (length(feat_vec) + 1 >= depth) stopsplit = TRUE  }
}
# summing up gini index differences for each feature
gini_sum = c()
for (i in 1:length(allfeat)){
gini_sum[i] = sum(gini_vec[which(feat_vec == allfeat[i])])
}
output
j
# empty vector for gini index:
gini=c()
min_split = c()
data.temp = data.list[[j]]
# for random forrest
if(!is.null(type)){if(type == "rf") feat = sample(allfeat, size = nfeat, replace = FALSE)}
# calculating gini index:
for (i in 1:length(feat)){
data.gini = data.frame(var = data.temp[, feat[i]], resp = data.temp[, resp])
# gini index of parent node
count = table(data.gini)
gini_parent = 1 - sum((count / sum(count)) ^ 2)
# calculating sse for categorical feature:
if( is.factor(data.gini$var) ) {
data.gini.list = split(data.gini, data.gini$var)
gini[i] = sum(sapply(data.gini.list, function(x){
count = table(x)
gini = 1 - sum((count / sum(count)) ^ 2)
gini * sum(count)
}) / nrow(data.gini))
# checking size of children nodes; if less than specified, the split is not considered
count_min = min(sapply(data.gini.list, nrow))
if( count_min < leafsize) gini[i] = NA
} else {
# calculating gini index for continuous feature:
gini_splits = c()
splits_sort = sort(unique(data.gini$var))
if (length(unique(splits_sort)) < 2) {gini[i] = NA; min_split[i] = NA}
else {
for( k in 2:length(splits_sort)){
data.gini = data.frame(var = data.temp[, feat[i]], data.temp[, resp])
data.gini$var = cut(data.gini$var, breaks =c(splits_sort[1],mean(c(splits_sort[k-1], splits_sort[k])), max(splits_sort)+1 ), right=FALSE)
data.gini.list = split(data.gini, data.gini$var)
gini_splits[k-1] = sum(sapply(data.gini.list, function(x){
count = table(x)
gini = 1 - sum((count / sum(count)) ^ 2)
gini * sum(count)
}) / nrow(data.gini))
# checking size of children nodes; if less than specified, the split is not considered
count_min = min(sapply(data.gini.list, nrow))
if(count_min < round(leafsize)) gini_splits[k-1] = NA
}
}
# calculating sse for all possible splits
# clean up for when none of the splits is valid:
if(all(is.na(gini_splits))) {
gini[i] = NA
min_split[i] = NA
} else {
gini[i] = min(gini_splits, na.rm = TRUE)
min_split[i] = splits_sort[which.min(gini_splits)]}
}
}
# characteristics of the current split
split.var = feat[which.min(gini)] # feature leading to the lowest gini index
gini_diff = gini_parent - min(gini, na.rm = TRUE) # difference in gini index
gini
table(data$gender, data$readmitted)
data
table(data$gender, data$readmitted)
data$readmitted
data = read.csv(file = "diabetic_data.csv")
data = data[unique_id, ]
# can delete encounter_id now
data$encounter_id <- NULL
data$weight <- NULL
data$payer_code <- NULL
# 2. remove patients that entered hospice or passed away after discharge
data = data[ -which(data$discharge_disposition_id %in% c(11, 13, 14, 19, 20, 21)), ]
nrow(data)
# 69973, which is 11 less than the value reported in the paper (69984)
# re-coding:
data$readmitted = as.factor(ifelse(data$readmitted == "<30", "YES", "NO"))
data$A1Cresult
data$A1Cresult2 = as.factor(ifelse(data$A1Cresult %in% c("Norm", ">7"), "Normal", ifelse(data$A1Cresult == "None", "None", ifelse(data$change == "Ch", "high_ch", "high_noch"))))
data$discharge_disposition_id = as.factor(ifelse(data$discharge_disposition_id == 1, "Home", "Other"))
data$admission_source_id = as.factor(ifelse(data$admission_source_id == 7, "Emergency", ifelse(data$admission_source_id %in% c(1,2), "Referral", "Other")))
data$medical_specialty <- replace(data$medical_specialty, data$medical_specialty == "Cardiology-Pediatric", "Cardiology")
data$medical_specialty <- replace(data$medical_specialty, data$medical_specialty == "Surgeon", "SurgicalSpecialty")
data$medical_specialty <- replace(data$medical_specialty, data$medical_specialty == "Surgery-Cardiovascular/Thoracic", "SurgicalSpecialty")
data$medical_specialty <- replace(data$medical_specialty, data$medical_specialty == "Surgery-Colon&Rectal", "SurgicalSpecialty")
data$medical_specialty <- replace(data$medical_specialty, data$medical_specialty == "Surgery-General", "SurgicalSpecialty")
data$medical_specialty <- replace(data$medical_specialty, data$medical_specialty == "Surgery-Maxillofacial", "SurgicalSpecialty")
data$medical_specialty <- replace(data$medical_specialty, data$medical_specialty == "Surgery-Neuro", "SurgicalSpecialty")
data$medical_specialty <- replace(data$medical_specialty, data$medical_specialty == "Surgery-Pediatric", "SurgicalSpecialty")
data$medical_specialty <- replace(data$medical_specialty, data$medical_specialty == "Surgery-Plastic", "SurgicalSpecialty")
data$medical_specialty <- replace(data$medical_specialty, data$medical_specialty == "Surgery-PlasticwithinHeadandNeck", "SurgicalSpecialty")
data$medical_specialty <- replace(data$medical_specialty, data$medical_specialty == "Surgery-Thoracic", "SurgicalSpecialty")
data$medical_specialty <- replace(data$medical_specialty, data$medical_specialty == "Surgery-Vascular", "SurgicalSpecialty")
data$medical_specialty <- str_replace(data$medical_specialty, "SurgicalSpecialty", "Surgery")
data$medical_specialty[which(data$medical_specialty == "?")] = "Missing or Unknown"
data$medical_specialty[which(!(data$medical_specialty %in% c("InternalMedicine", "Cardiology", "Surgery", "Family/GeneralPractice", "Missing or Unknown")))] = "Other"
diag_diabetes = levels(data$diag_1)[which(substr(levels(data$diag_1), 1, 3)==250)]
diag_other = levels(data$diag_1)[which(!(levels(data$diag_1) %in% c(390:459, 785, diag_diabetes, 460:519, 786, 520:579, 787, 800:999, 710:739, 580:629, 788, 140:239)))]
levels(data$diag_1) <- list(
"Circulatory" = c(390:459, 785),
"Diabetes" = diag_diabetes,
"Respiratory" = c(460:519, 786),
"Digestive" = c(520:579, 787),
"Injury and poisoning" = c(800:999),
"Musculoskeletal" = c(710:739),
"Genitourinary" = c(580:629, 788),
"Neoplasms" = c(140:239),
"Other" = diag_other
)
levels(data$race) = list("Missing" = "?", "Other" = c("Other", "Asian", "Hispanic"), "African American" = "AfricanAmerican", "Caucasian" = "Caucasian" )
data$age_num = data$age
levels(data$age_num) = list("5" = "[0-10)", "15" = "[10-20)", "25" = "[20-30)", "35" = "[30-40)", "45" = "[40-50)", "55" = "[50-60)", "65" = "[60-70)", "75" = "[70-80)", "85" = "[80-90)", "95" = "[90-100)")
data$age_num = as.numeric(as.character(data$age_num))
levels(data$age) = list("30 years old or younger" = c("[0-10)", "[10-20)", "[20-30)" ), "30–60 years old" = c("[30-40)", "[40-50)", "[50-60)"), "Other" = c("[60-70)", "[70-80)", "[80-90)", "[90-100)"))
data$medical_specialty <- as.factor(data$medical_specialty)
data$medical_specialty <-droplevels(data$medical_specialty)
table(data$A1Cresult2, data$readmitted)
table(data$gender, data$readmitted)
table(data$gender)
table(data$medical_specialty)
summary(fit)
fit2 = glm(readmitted ~ discharge_disposition_id + race + admission_source_id + medical_specialty + time_in_hospital + age + diag_1 + A1Cresult2, family = "binomial", data = data)
summary(fit2)
data$admission_type_id
table(data$admission_source_id, data$readmitted)
